// This file was generated by counterfeiter
package fakes

import (
	"route_populator/publisher"
	"sync"
)

type FakePublishingConnection struct {
	PublishStub        func(subj string, data []byte) error
	publishMutex       sync.RWMutex
	publishArgsForCall []struct {
		subj string
		data []byte
	}
	publishReturns struct {
		result1 error
	}
	CloseStub        func()
	closeMutex       sync.RWMutex
	closeArgsForCall []struct{}
}

func (fake *FakePublishingConnection) Publish(subj string, data []byte) error {
	fake.publishMutex.Lock()
	fake.publishArgsForCall = append(fake.publishArgsForCall, struct {
		subj string
		data []byte
	}{subj, data})
	fake.publishMutex.Unlock()
	if fake.PublishStub != nil {
		return fake.PublishStub(subj, data)
	} else {
		return fake.publishReturns.result1
	}
}

func (fake *FakePublishingConnection) PublishCallCount() int {
	fake.publishMutex.RLock()
	defer fake.publishMutex.RUnlock()
	return len(fake.publishArgsForCall)
}

func (fake *FakePublishingConnection) PublishArgsForCall(i int) (string, []byte) {
	fake.publishMutex.RLock()
	defer fake.publishMutex.RUnlock()
	return fake.publishArgsForCall[i].subj, fake.publishArgsForCall[i].data
}

func (fake *FakePublishingConnection) PublishReturns(result1 error) {
	fake.PublishStub = nil
	fake.publishReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePublishingConnection) Close() {
	fake.closeMutex.Lock()
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct{}{})
	fake.closeMutex.Unlock()
	if fake.CloseStub != nil {
		fake.CloseStub()
	}
}

func (fake *FakePublishingConnection) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

var _ publisher.PublishingConnection = new(FakePublishingConnection)
