// This file was generated by counterfeiter
package fakes

import "sync"

type ApiCliAdapter struct {
	SetApiWithSslStub        func(api string) error
	setApiWithSslMutex       sync.RWMutex
	setApiWithSslArgsForCall []struct {
		api string
	}
	setApiWithSslReturns struct {
		result1 error
	}
	SetApiWithoutSslStub        func(api string) error
	setApiWithoutSslMutex       sync.RWMutex
	setApiWithoutSslArgsForCall []struct {
		api string
	}
	setApiWithoutSslReturns struct {
		result1 error
	}
	AuthStub        func(user, password string) error
	authMutex       sync.RWMutex
	authArgsForCall []struct {
		user     string
		password string
	}
	authReturns struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *ApiCliAdapter) SetApiWithSsl(api string) error {
	fake.setApiWithSslMutex.Lock()
	fake.setApiWithSslArgsForCall = append(fake.setApiWithSslArgsForCall, struct {
		api string
	}{api})
	fake.recordInvocation("SetApiWithSsl", []interface{}{api})
	fake.setApiWithSslMutex.Unlock()
	if fake.SetApiWithSslStub != nil {
		return fake.SetApiWithSslStub(api)
	} else {
		return fake.setApiWithSslReturns.result1
	}
}

func (fake *ApiCliAdapter) SetApiWithSslCallCount() int {
	fake.setApiWithSslMutex.RLock()
	defer fake.setApiWithSslMutex.RUnlock()
	return len(fake.setApiWithSslArgsForCall)
}

func (fake *ApiCliAdapter) SetApiWithSslArgsForCall(i int) string {
	fake.setApiWithSslMutex.RLock()
	defer fake.setApiWithSslMutex.RUnlock()
	return fake.setApiWithSslArgsForCall[i].api
}

func (fake *ApiCliAdapter) SetApiWithSslReturns(result1 error) {
	fake.SetApiWithSslStub = nil
	fake.setApiWithSslReturns = struct {
		result1 error
	}{result1}
}

func (fake *ApiCliAdapter) SetApiWithoutSsl(api string) error {
	fake.setApiWithoutSslMutex.Lock()
	fake.setApiWithoutSslArgsForCall = append(fake.setApiWithoutSslArgsForCall, struct {
		api string
	}{api})
	fake.recordInvocation("SetApiWithoutSsl", []interface{}{api})
	fake.setApiWithoutSslMutex.Unlock()
	if fake.SetApiWithoutSslStub != nil {
		return fake.SetApiWithoutSslStub(api)
	} else {
		return fake.setApiWithoutSslReturns.result1
	}
}

func (fake *ApiCliAdapter) SetApiWithoutSslCallCount() int {
	fake.setApiWithoutSslMutex.RLock()
	defer fake.setApiWithoutSslMutex.RUnlock()
	return len(fake.setApiWithoutSslArgsForCall)
}

func (fake *ApiCliAdapter) SetApiWithoutSslArgsForCall(i int) string {
	fake.setApiWithoutSslMutex.RLock()
	defer fake.setApiWithoutSslMutex.RUnlock()
	return fake.setApiWithoutSslArgsForCall[i].api
}

func (fake *ApiCliAdapter) SetApiWithoutSslReturns(result1 error) {
	fake.SetApiWithoutSslStub = nil
	fake.setApiWithoutSslReturns = struct {
		result1 error
	}{result1}
}

func (fake *ApiCliAdapter) Auth(user string, password string) error {
	fake.authMutex.Lock()
	fake.authArgsForCall = append(fake.authArgsForCall, struct {
		user     string
		password string
	}{user, password})
	fake.recordInvocation("Auth", []interface{}{user, password})
	fake.authMutex.Unlock()
	if fake.AuthStub != nil {
		return fake.AuthStub(user, password)
	} else {
		return fake.authReturns.result1
	}
}

func (fake *ApiCliAdapter) AuthCallCount() int {
	fake.authMutex.RLock()
	defer fake.authMutex.RUnlock()
	return len(fake.authArgsForCall)
}

func (fake *ApiCliAdapter) AuthArgsForCall(i int) (string, string) {
	fake.authMutex.RLock()
	defer fake.authMutex.RUnlock()
	return fake.authArgsForCall[i].user, fake.authArgsForCall[i].password
}

func (fake *ApiCliAdapter) AuthReturns(result1 error) {
	fake.AuthStub = nil
	fake.authReturns = struct {
		result1 error
	}{result1}
}

func (fake *ApiCliAdapter) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.setApiWithSslMutex.RLock()
	defer fake.setApiWithSslMutex.RUnlock()
	fake.setApiWithoutSslMutex.RLock()
	defer fake.setApiWithoutSslMutex.RUnlock()
	fake.authMutex.RLock()
	defer fake.authMutex.RUnlock()
	return fake.invocations
}

func (fake *ApiCliAdapter) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
