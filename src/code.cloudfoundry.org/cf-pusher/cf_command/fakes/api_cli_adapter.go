// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"
)

type ApiCliAdapter struct {
	AuthStub        func(string, string) error
	authMutex       sync.RWMutex
	authArgsForCall []struct {
		arg1 string
		arg2 string
	}
	authReturns struct {
		result1 error
	}
	authReturnsOnCall map[int]struct {
		result1 error
	}
	SetApiWithSslStub        func(string) error
	setApiWithSslMutex       sync.RWMutex
	setApiWithSslArgsForCall []struct {
		arg1 string
	}
	setApiWithSslReturns struct {
		result1 error
	}
	setApiWithSslReturnsOnCall map[int]struct {
		result1 error
	}
	SetApiWithoutSslStub        func(string) error
	setApiWithoutSslMutex       sync.RWMutex
	setApiWithoutSslArgsForCall []struct {
		arg1 string
	}
	setApiWithoutSslReturns struct {
		result1 error
	}
	setApiWithoutSslReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *ApiCliAdapter) Auth(arg1 string, arg2 string) error {
	fake.authMutex.Lock()
	ret, specificReturn := fake.authReturnsOnCall[len(fake.authArgsForCall)]
	fake.authArgsForCall = append(fake.authArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.AuthStub
	fakeReturns := fake.authReturns
	fake.recordInvocation("Auth", []interface{}{arg1, arg2})
	fake.authMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ApiCliAdapter) AuthCallCount() int {
	fake.authMutex.RLock()
	defer fake.authMutex.RUnlock()
	return len(fake.authArgsForCall)
}

func (fake *ApiCliAdapter) AuthCalls(stub func(string, string) error) {
	fake.authMutex.Lock()
	defer fake.authMutex.Unlock()
	fake.AuthStub = stub
}

func (fake *ApiCliAdapter) AuthArgsForCall(i int) (string, string) {
	fake.authMutex.RLock()
	defer fake.authMutex.RUnlock()
	argsForCall := fake.authArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *ApiCliAdapter) AuthReturns(result1 error) {
	fake.authMutex.Lock()
	defer fake.authMutex.Unlock()
	fake.AuthStub = nil
	fake.authReturns = struct {
		result1 error
	}{result1}
}

func (fake *ApiCliAdapter) AuthReturnsOnCall(i int, result1 error) {
	fake.authMutex.Lock()
	defer fake.authMutex.Unlock()
	fake.AuthStub = nil
	if fake.authReturnsOnCall == nil {
		fake.authReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.authReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *ApiCliAdapter) SetApiWithSsl(arg1 string) error {
	fake.setApiWithSslMutex.Lock()
	ret, specificReturn := fake.setApiWithSslReturnsOnCall[len(fake.setApiWithSslArgsForCall)]
	fake.setApiWithSslArgsForCall = append(fake.setApiWithSslArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.SetApiWithSslStub
	fakeReturns := fake.setApiWithSslReturns
	fake.recordInvocation("SetApiWithSsl", []interface{}{arg1})
	fake.setApiWithSslMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ApiCliAdapter) SetApiWithSslCallCount() int {
	fake.setApiWithSslMutex.RLock()
	defer fake.setApiWithSslMutex.RUnlock()
	return len(fake.setApiWithSslArgsForCall)
}

func (fake *ApiCliAdapter) SetApiWithSslCalls(stub func(string) error) {
	fake.setApiWithSslMutex.Lock()
	defer fake.setApiWithSslMutex.Unlock()
	fake.SetApiWithSslStub = stub
}

func (fake *ApiCliAdapter) SetApiWithSslArgsForCall(i int) string {
	fake.setApiWithSslMutex.RLock()
	defer fake.setApiWithSslMutex.RUnlock()
	argsForCall := fake.setApiWithSslArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ApiCliAdapter) SetApiWithSslReturns(result1 error) {
	fake.setApiWithSslMutex.Lock()
	defer fake.setApiWithSslMutex.Unlock()
	fake.SetApiWithSslStub = nil
	fake.setApiWithSslReturns = struct {
		result1 error
	}{result1}
}

func (fake *ApiCliAdapter) SetApiWithSslReturnsOnCall(i int, result1 error) {
	fake.setApiWithSslMutex.Lock()
	defer fake.setApiWithSslMutex.Unlock()
	fake.SetApiWithSslStub = nil
	if fake.setApiWithSslReturnsOnCall == nil {
		fake.setApiWithSslReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setApiWithSslReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *ApiCliAdapter) SetApiWithoutSsl(arg1 string) error {
	fake.setApiWithoutSslMutex.Lock()
	ret, specificReturn := fake.setApiWithoutSslReturnsOnCall[len(fake.setApiWithoutSslArgsForCall)]
	fake.setApiWithoutSslArgsForCall = append(fake.setApiWithoutSslArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.SetApiWithoutSslStub
	fakeReturns := fake.setApiWithoutSslReturns
	fake.recordInvocation("SetApiWithoutSsl", []interface{}{arg1})
	fake.setApiWithoutSslMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ApiCliAdapter) SetApiWithoutSslCallCount() int {
	fake.setApiWithoutSslMutex.RLock()
	defer fake.setApiWithoutSslMutex.RUnlock()
	return len(fake.setApiWithoutSslArgsForCall)
}

func (fake *ApiCliAdapter) SetApiWithoutSslCalls(stub func(string) error) {
	fake.setApiWithoutSslMutex.Lock()
	defer fake.setApiWithoutSslMutex.Unlock()
	fake.SetApiWithoutSslStub = stub
}

func (fake *ApiCliAdapter) SetApiWithoutSslArgsForCall(i int) string {
	fake.setApiWithoutSslMutex.RLock()
	defer fake.setApiWithoutSslMutex.RUnlock()
	argsForCall := fake.setApiWithoutSslArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ApiCliAdapter) SetApiWithoutSslReturns(result1 error) {
	fake.setApiWithoutSslMutex.Lock()
	defer fake.setApiWithoutSslMutex.Unlock()
	fake.SetApiWithoutSslStub = nil
	fake.setApiWithoutSslReturns = struct {
		result1 error
	}{result1}
}

func (fake *ApiCliAdapter) SetApiWithoutSslReturnsOnCall(i int, result1 error) {
	fake.setApiWithoutSslMutex.Lock()
	defer fake.setApiWithoutSslMutex.Unlock()
	fake.SetApiWithoutSslStub = nil
	if fake.setApiWithoutSslReturnsOnCall == nil {
		fake.setApiWithoutSslReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setApiWithoutSslReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *ApiCliAdapter) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.authMutex.RLock()
	defer fake.authMutex.RUnlock()
	fake.setApiWithSslMutex.RLock()
	defer fake.setApiWithSslMutex.RUnlock()
	fake.setApiWithoutSslMutex.RLock()
	defer fake.setApiWithoutSslMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *ApiCliAdapter) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
