// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"database/sql"
	"sync"

	"code.cloudfoundry.org/cf-networking-helpers/db"
	"code.cloudfoundry.org/policy-server/store"
	"github.com/jmoiron/sqlx"
)

type Db struct {
	BeginxStub        func() (db.Transaction, error)
	beginxMutex       sync.RWMutex
	beginxArgsForCall []struct {
	}
	beginxReturns struct {
		result1 db.Transaction
		result2 error
	}
	beginxReturnsOnCall map[int]struct {
		result1 db.Transaction
		result2 error
	}
	DriverNameStub        func() string
	driverNameMutex       sync.RWMutex
	driverNameArgsForCall []struct {
	}
	driverNameReturns struct {
		result1 string
	}
	driverNameReturnsOnCall map[int]struct {
		result1 string
	}
	ExecStub        func(string, ...interface{}) (sql.Result, error)
	execMutex       sync.RWMutex
	execArgsForCall []struct {
		arg1 string
		arg2 []interface{}
	}
	execReturns struct {
		result1 sql.Result
		result2 error
	}
	execReturnsOnCall map[int]struct {
		result1 sql.Result
		result2 error
	}
	GetStub        func(interface{}, string, ...interface{}) error
	getMutex       sync.RWMutex
	getArgsForCall []struct {
		arg1 interface{}
		arg2 string
		arg3 []interface{}
	}
	getReturns struct {
		result1 error
	}
	getReturnsOnCall map[int]struct {
		result1 error
	}
	NamedExecStub        func(string, interface{}) (sql.Result, error)
	namedExecMutex       sync.RWMutex
	namedExecArgsForCall []struct {
		arg1 string
		arg2 interface{}
	}
	namedExecReturns struct {
		result1 sql.Result
		result2 error
	}
	namedExecReturnsOnCall map[int]struct {
		result1 sql.Result
		result2 error
	}
	QueryStub        func(string, ...interface{}) (*sql.Rows, error)
	queryMutex       sync.RWMutex
	queryArgsForCall []struct {
		arg1 string
		arg2 []interface{}
	}
	queryReturns struct {
		result1 *sql.Rows
		result2 error
	}
	queryReturnsOnCall map[int]struct {
		result1 *sql.Rows
		result2 error
	}
	QueryRowStub        func(string, ...interface{}) *sql.Row
	queryRowMutex       sync.RWMutex
	queryRowArgsForCall []struct {
		arg1 string
		arg2 []interface{}
	}
	queryRowReturns struct {
		result1 *sql.Row
	}
	queryRowReturnsOnCall map[int]struct {
		result1 *sql.Row
	}
	RawConnectionStub        func() *sqlx.DB
	rawConnectionMutex       sync.RWMutex
	rawConnectionArgsForCall []struct {
	}
	rawConnectionReturns struct {
		result1 *sqlx.DB
	}
	rawConnectionReturnsOnCall map[int]struct {
		result1 *sqlx.DB
	}
	RebindStub        func(string) string
	rebindMutex       sync.RWMutex
	rebindArgsForCall []struct {
		arg1 string
	}
	rebindReturns struct {
		result1 string
	}
	rebindReturnsOnCall map[int]struct {
		result1 string
	}
	SelectStub        func(interface{}, string, ...interface{}) error
	selectMutex       sync.RWMutex
	selectArgsForCall []struct {
		arg1 interface{}
		arg2 string
		arg3 []interface{}
	}
	selectReturns struct {
		result1 error
	}
	selectReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *Db) Beginx() (db.Transaction, error) {
	fake.beginxMutex.Lock()
	ret, specificReturn := fake.beginxReturnsOnCall[len(fake.beginxArgsForCall)]
	fake.beginxArgsForCall = append(fake.beginxArgsForCall, struct {
	}{})
	stub := fake.BeginxStub
	fakeReturns := fake.beginxReturns
	fake.recordInvocation("Beginx", []interface{}{})
	fake.beginxMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Db) BeginxCallCount() int {
	fake.beginxMutex.RLock()
	defer fake.beginxMutex.RUnlock()
	return len(fake.beginxArgsForCall)
}

func (fake *Db) BeginxCalls(stub func() (db.Transaction, error)) {
	fake.beginxMutex.Lock()
	defer fake.beginxMutex.Unlock()
	fake.BeginxStub = stub
}

func (fake *Db) BeginxReturns(result1 db.Transaction, result2 error) {
	fake.beginxMutex.Lock()
	defer fake.beginxMutex.Unlock()
	fake.BeginxStub = nil
	fake.beginxReturns = struct {
		result1 db.Transaction
		result2 error
	}{result1, result2}
}

func (fake *Db) BeginxReturnsOnCall(i int, result1 db.Transaction, result2 error) {
	fake.beginxMutex.Lock()
	defer fake.beginxMutex.Unlock()
	fake.BeginxStub = nil
	if fake.beginxReturnsOnCall == nil {
		fake.beginxReturnsOnCall = make(map[int]struct {
			result1 db.Transaction
			result2 error
		})
	}
	fake.beginxReturnsOnCall[i] = struct {
		result1 db.Transaction
		result2 error
	}{result1, result2}
}

func (fake *Db) DriverName() string {
	fake.driverNameMutex.Lock()
	ret, specificReturn := fake.driverNameReturnsOnCall[len(fake.driverNameArgsForCall)]
	fake.driverNameArgsForCall = append(fake.driverNameArgsForCall, struct {
	}{})
	stub := fake.DriverNameStub
	fakeReturns := fake.driverNameReturns
	fake.recordInvocation("DriverName", []interface{}{})
	fake.driverNameMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Db) DriverNameCallCount() int {
	fake.driverNameMutex.RLock()
	defer fake.driverNameMutex.RUnlock()
	return len(fake.driverNameArgsForCall)
}

func (fake *Db) DriverNameCalls(stub func() string) {
	fake.driverNameMutex.Lock()
	defer fake.driverNameMutex.Unlock()
	fake.DriverNameStub = stub
}

func (fake *Db) DriverNameReturns(result1 string) {
	fake.driverNameMutex.Lock()
	defer fake.driverNameMutex.Unlock()
	fake.DriverNameStub = nil
	fake.driverNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *Db) DriverNameReturnsOnCall(i int, result1 string) {
	fake.driverNameMutex.Lock()
	defer fake.driverNameMutex.Unlock()
	fake.DriverNameStub = nil
	if fake.driverNameReturnsOnCall == nil {
		fake.driverNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.driverNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *Db) Exec(arg1 string, arg2 ...interface{}) (sql.Result, error) {
	fake.execMutex.Lock()
	ret, specificReturn := fake.execReturnsOnCall[len(fake.execArgsForCall)]
	fake.execArgsForCall = append(fake.execArgsForCall, struct {
		arg1 string
		arg2 []interface{}
	}{arg1, arg2})
	stub := fake.ExecStub
	fakeReturns := fake.execReturns
	fake.recordInvocation("Exec", []interface{}{arg1, arg2})
	fake.execMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Db) ExecCallCount() int {
	fake.execMutex.RLock()
	defer fake.execMutex.RUnlock()
	return len(fake.execArgsForCall)
}

func (fake *Db) ExecCalls(stub func(string, ...interface{}) (sql.Result, error)) {
	fake.execMutex.Lock()
	defer fake.execMutex.Unlock()
	fake.ExecStub = stub
}

func (fake *Db) ExecArgsForCall(i int) (string, []interface{}) {
	fake.execMutex.RLock()
	defer fake.execMutex.RUnlock()
	argsForCall := fake.execArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Db) ExecReturns(result1 sql.Result, result2 error) {
	fake.execMutex.Lock()
	defer fake.execMutex.Unlock()
	fake.ExecStub = nil
	fake.execReturns = struct {
		result1 sql.Result
		result2 error
	}{result1, result2}
}

func (fake *Db) ExecReturnsOnCall(i int, result1 sql.Result, result2 error) {
	fake.execMutex.Lock()
	defer fake.execMutex.Unlock()
	fake.ExecStub = nil
	if fake.execReturnsOnCall == nil {
		fake.execReturnsOnCall = make(map[int]struct {
			result1 sql.Result
			result2 error
		})
	}
	fake.execReturnsOnCall[i] = struct {
		result1 sql.Result
		result2 error
	}{result1, result2}
}

func (fake *Db) Get(arg1 interface{}, arg2 string, arg3 ...interface{}) error {
	fake.getMutex.Lock()
	ret, specificReturn := fake.getReturnsOnCall[len(fake.getArgsForCall)]
	fake.getArgsForCall = append(fake.getArgsForCall, struct {
		arg1 interface{}
		arg2 string
		arg3 []interface{}
	}{arg1, arg2, arg3})
	stub := fake.GetStub
	fakeReturns := fake.getReturns
	fake.recordInvocation("Get", []interface{}{arg1, arg2, arg3})
	fake.getMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Db) GetCallCount() int {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return len(fake.getArgsForCall)
}

func (fake *Db) GetCalls(stub func(interface{}, string, ...interface{}) error) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = stub
}

func (fake *Db) GetArgsForCall(i int) (interface{}, string, []interface{}) {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	argsForCall := fake.getArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *Db) GetReturns(result1 error) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	fake.getReturns = struct {
		result1 error
	}{result1}
}

func (fake *Db) GetReturnsOnCall(i int, result1 error) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	if fake.getReturnsOnCall == nil {
		fake.getReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.getReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Db) NamedExec(arg1 string, arg2 interface{}) (sql.Result, error) {
	fake.namedExecMutex.Lock()
	ret, specificReturn := fake.namedExecReturnsOnCall[len(fake.namedExecArgsForCall)]
	fake.namedExecArgsForCall = append(fake.namedExecArgsForCall, struct {
		arg1 string
		arg2 interface{}
	}{arg1, arg2})
	stub := fake.NamedExecStub
	fakeReturns := fake.namedExecReturns
	fake.recordInvocation("NamedExec", []interface{}{arg1, arg2})
	fake.namedExecMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Db) NamedExecCallCount() int {
	fake.namedExecMutex.RLock()
	defer fake.namedExecMutex.RUnlock()
	return len(fake.namedExecArgsForCall)
}

func (fake *Db) NamedExecCalls(stub func(string, interface{}) (sql.Result, error)) {
	fake.namedExecMutex.Lock()
	defer fake.namedExecMutex.Unlock()
	fake.NamedExecStub = stub
}

func (fake *Db) NamedExecArgsForCall(i int) (string, interface{}) {
	fake.namedExecMutex.RLock()
	defer fake.namedExecMutex.RUnlock()
	argsForCall := fake.namedExecArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Db) NamedExecReturns(result1 sql.Result, result2 error) {
	fake.namedExecMutex.Lock()
	defer fake.namedExecMutex.Unlock()
	fake.NamedExecStub = nil
	fake.namedExecReturns = struct {
		result1 sql.Result
		result2 error
	}{result1, result2}
}

func (fake *Db) NamedExecReturnsOnCall(i int, result1 sql.Result, result2 error) {
	fake.namedExecMutex.Lock()
	defer fake.namedExecMutex.Unlock()
	fake.NamedExecStub = nil
	if fake.namedExecReturnsOnCall == nil {
		fake.namedExecReturnsOnCall = make(map[int]struct {
			result1 sql.Result
			result2 error
		})
	}
	fake.namedExecReturnsOnCall[i] = struct {
		result1 sql.Result
		result2 error
	}{result1, result2}
}

func (fake *Db) Query(arg1 string, arg2 ...interface{}) (*sql.Rows, error) {
	fake.queryMutex.Lock()
	ret, specificReturn := fake.queryReturnsOnCall[len(fake.queryArgsForCall)]
	fake.queryArgsForCall = append(fake.queryArgsForCall, struct {
		arg1 string
		arg2 []interface{}
	}{arg1, arg2})
	stub := fake.QueryStub
	fakeReturns := fake.queryReturns
	fake.recordInvocation("Query", []interface{}{arg1, arg2})
	fake.queryMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Db) QueryCallCount() int {
	fake.queryMutex.RLock()
	defer fake.queryMutex.RUnlock()
	return len(fake.queryArgsForCall)
}

func (fake *Db) QueryCalls(stub func(string, ...interface{}) (*sql.Rows, error)) {
	fake.queryMutex.Lock()
	defer fake.queryMutex.Unlock()
	fake.QueryStub = stub
}

func (fake *Db) QueryArgsForCall(i int) (string, []interface{}) {
	fake.queryMutex.RLock()
	defer fake.queryMutex.RUnlock()
	argsForCall := fake.queryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Db) QueryReturns(result1 *sql.Rows, result2 error) {
	fake.queryMutex.Lock()
	defer fake.queryMutex.Unlock()
	fake.QueryStub = nil
	fake.queryReturns = struct {
		result1 *sql.Rows
		result2 error
	}{result1, result2}
}

func (fake *Db) QueryReturnsOnCall(i int, result1 *sql.Rows, result2 error) {
	fake.queryMutex.Lock()
	defer fake.queryMutex.Unlock()
	fake.QueryStub = nil
	if fake.queryReturnsOnCall == nil {
		fake.queryReturnsOnCall = make(map[int]struct {
			result1 *sql.Rows
			result2 error
		})
	}
	fake.queryReturnsOnCall[i] = struct {
		result1 *sql.Rows
		result2 error
	}{result1, result2}
}

func (fake *Db) QueryRow(arg1 string, arg2 ...interface{}) *sql.Row {
	fake.queryRowMutex.Lock()
	ret, specificReturn := fake.queryRowReturnsOnCall[len(fake.queryRowArgsForCall)]
	fake.queryRowArgsForCall = append(fake.queryRowArgsForCall, struct {
		arg1 string
		arg2 []interface{}
	}{arg1, arg2})
	stub := fake.QueryRowStub
	fakeReturns := fake.queryRowReturns
	fake.recordInvocation("QueryRow", []interface{}{arg1, arg2})
	fake.queryRowMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Db) QueryRowCallCount() int {
	fake.queryRowMutex.RLock()
	defer fake.queryRowMutex.RUnlock()
	return len(fake.queryRowArgsForCall)
}

func (fake *Db) QueryRowCalls(stub func(string, ...interface{}) *sql.Row) {
	fake.queryRowMutex.Lock()
	defer fake.queryRowMutex.Unlock()
	fake.QueryRowStub = stub
}

func (fake *Db) QueryRowArgsForCall(i int) (string, []interface{}) {
	fake.queryRowMutex.RLock()
	defer fake.queryRowMutex.RUnlock()
	argsForCall := fake.queryRowArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Db) QueryRowReturns(result1 *sql.Row) {
	fake.queryRowMutex.Lock()
	defer fake.queryRowMutex.Unlock()
	fake.QueryRowStub = nil
	fake.queryRowReturns = struct {
		result1 *sql.Row
	}{result1}
}

func (fake *Db) QueryRowReturnsOnCall(i int, result1 *sql.Row) {
	fake.queryRowMutex.Lock()
	defer fake.queryRowMutex.Unlock()
	fake.QueryRowStub = nil
	if fake.queryRowReturnsOnCall == nil {
		fake.queryRowReturnsOnCall = make(map[int]struct {
			result1 *sql.Row
		})
	}
	fake.queryRowReturnsOnCall[i] = struct {
		result1 *sql.Row
	}{result1}
}

func (fake *Db) RawConnection() *sqlx.DB {
	fake.rawConnectionMutex.Lock()
	ret, specificReturn := fake.rawConnectionReturnsOnCall[len(fake.rawConnectionArgsForCall)]
	fake.rawConnectionArgsForCall = append(fake.rawConnectionArgsForCall, struct {
	}{})
	stub := fake.RawConnectionStub
	fakeReturns := fake.rawConnectionReturns
	fake.recordInvocation("RawConnection", []interface{}{})
	fake.rawConnectionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Db) RawConnectionCallCount() int {
	fake.rawConnectionMutex.RLock()
	defer fake.rawConnectionMutex.RUnlock()
	return len(fake.rawConnectionArgsForCall)
}

func (fake *Db) RawConnectionCalls(stub func() *sqlx.DB) {
	fake.rawConnectionMutex.Lock()
	defer fake.rawConnectionMutex.Unlock()
	fake.RawConnectionStub = stub
}

func (fake *Db) RawConnectionReturns(result1 *sqlx.DB) {
	fake.rawConnectionMutex.Lock()
	defer fake.rawConnectionMutex.Unlock()
	fake.RawConnectionStub = nil
	fake.rawConnectionReturns = struct {
		result1 *sqlx.DB
	}{result1}
}

func (fake *Db) RawConnectionReturnsOnCall(i int, result1 *sqlx.DB) {
	fake.rawConnectionMutex.Lock()
	defer fake.rawConnectionMutex.Unlock()
	fake.RawConnectionStub = nil
	if fake.rawConnectionReturnsOnCall == nil {
		fake.rawConnectionReturnsOnCall = make(map[int]struct {
			result1 *sqlx.DB
		})
	}
	fake.rawConnectionReturnsOnCall[i] = struct {
		result1 *sqlx.DB
	}{result1}
}

func (fake *Db) Rebind(arg1 string) string {
	fake.rebindMutex.Lock()
	ret, specificReturn := fake.rebindReturnsOnCall[len(fake.rebindArgsForCall)]
	fake.rebindArgsForCall = append(fake.rebindArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.RebindStub
	fakeReturns := fake.rebindReturns
	fake.recordInvocation("Rebind", []interface{}{arg1})
	fake.rebindMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Db) RebindCallCount() int {
	fake.rebindMutex.RLock()
	defer fake.rebindMutex.RUnlock()
	return len(fake.rebindArgsForCall)
}

func (fake *Db) RebindCalls(stub func(string) string) {
	fake.rebindMutex.Lock()
	defer fake.rebindMutex.Unlock()
	fake.RebindStub = stub
}

func (fake *Db) RebindArgsForCall(i int) string {
	fake.rebindMutex.RLock()
	defer fake.rebindMutex.RUnlock()
	argsForCall := fake.rebindArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Db) RebindReturns(result1 string) {
	fake.rebindMutex.Lock()
	defer fake.rebindMutex.Unlock()
	fake.RebindStub = nil
	fake.rebindReturns = struct {
		result1 string
	}{result1}
}

func (fake *Db) RebindReturnsOnCall(i int, result1 string) {
	fake.rebindMutex.Lock()
	defer fake.rebindMutex.Unlock()
	fake.RebindStub = nil
	if fake.rebindReturnsOnCall == nil {
		fake.rebindReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.rebindReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *Db) Select(arg1 interface{}, arg2 string, arg3 ...interface{}) error {
	fake.selectMutex.Lock()
	ret, specificReturn := fake.selectReturnsOnCall[len(fake.selectArgsForCall)]
	fake.selectArgsForCall = append(fake.selectArgsForCall, struct {
		arg1 interface{}
		arg2 string
		arg3 []interface{}
	}{arg1, arg2, arg3})
	stub := fake.SelectStub
	fakeReturns := fake.selectReturns
	fake.recordInvocation("Select", []interface{}{arg1, arg2, arg3})
	fake.selectMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Db) SelectCallCount() int {
	fake.selectMutex.RLock()
	defer fake.selectMutex.RUnlock()
	return len(fake.selectArgsForCall)
}

func (fake *Db) SelectCalls(stub func(interface{}, string, ...interface{}) error) {
	fake.selectMutex.Lock()
	defer fake.selectMutex.Unlock()
	fake.SelectStub = stub
}

func (fake *Db) SelectArgsForCall(i int) (interface{}, string, []interface{}) {
	fake.selectMutex.RLock()
	defer fake.selectMutex.RUnlock()
	argsForCall := fake.selectArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *Db) SelectReturns(result1 error) {
	fake.selectMutex.Lock()
	defer fake.selectMutex.Unlock()
	fake.SelectStub = nil
	fake.selectReturns = struct {
		result1 error
	}{result1}
}

func (fake *Db) SelectReturnsOnCall(i int, result1 error) {
	fake.selectMutex.Lock()
	defer fake.selectMutex.Unlock()
	fake.SelectStub = nil
	if fake.selectReturnsOnCall == nil {
		fake.selectReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.selectReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Db) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.beginxMutex.RLock()
	defer fake.beginxMutex.RUnlock()
	fake.driverNameMutex.RLock()
	defer fake.driverNameMutex.RUnlock()
	fake.execMutex.RLock()
	defer fake.execMutex.RUnlock()
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	fake.namedExecMutex.RLock()
	defer fake.namedExecMutex.RUnlock()
	fake.queryMutex.RLock()
	defer fake.queryMutex.RUnlock()
	fake.queryRowMutex.RLock()
	defer fake.queryRowMutex.RUnlock()
	fake.rawConnectionMutex.RLock()
	defer fake.rawConnectionMutex.RUnlock()
	fake.rebindMutex.RLock()
	defer fake.rebindMutex.RUnlock()
	fake.selectMutex.RLock()
	defer fake.selectMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *Db) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ store.Database = new(Db)
